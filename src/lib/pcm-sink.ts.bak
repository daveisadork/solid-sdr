// types for the options
export interface PcmSinkOptions {
  sampleRate?: number; // default 24000
  channels?: number; // default 2
}

export class PcmSink {
  private ctx!: AudioContext;
  private node!: AudioWorkletNode;
  private msDest!: MediaStreamAudioDestinationNode;
  private audioEl!: HTMLAudioElement; // where we set sinkId
  private decoder?: AudioDecoder;
  private sampleRate: number; // typically 24000 for Opus
  private ptsUsec = 0; // synthetic timeline (microseconds) when caller doesn't provide PTS

  private channels: number;

  constructor({ sampleRate = 24000, channels = 2 }: PcmSinkOptions = {}) {
    this.channels = channels;
    this.sampleRate = sampleRate;

    this.ctx = new AudioContext({ sampleRate, latencyHint: "interactive" });
  }

  /** Load worklet, build graph, and get the audio element ready. */
  async init(): Promise<void> {
    try {
      this.decoder = new AudioDecoder({
        output: (audioData) => this.onDecoded(audioData),
        error: (e) => console.error("AudioDecoder error:", e),
      });

      this.decoder.configure({
        codec: "opus",
        numberOfChannels: this.channels,
        sampleRate: this.sampleRate,
      });
    } catch (e) {
      console.error("AudioDecoder not supported:", e);
    }
    console.log("AudioContext:", this.ctx);

    await this.ctx.audioWorklet.addModule(audioWorkletBlobUrl);
    this.node = new AudioWorkletNode(this.ctx, "pcm-sink", {
      numberOfInputs: 0,
      numberOfOutputs: 1,
      outputChannelCount: [this.channels],
    });

    // Instead of ctx.destination, route to a MediaStreamDestination
    this.msDest = new MediaStreamAudioDestinationNode(this.ctx, {
      channelCount: this.channels,
    });
    this.node.connect(this.msDest);

    // Hidden audio element that plays the stream and can switch sinks
    this.audioEl = new Audio();
    this.audioEl.autoplay = true;
    this.audioEl.playsInline = true;
    this.audioEl.muted = false; // must be user-gesture resumed
    this.audioEl.srcObject = this.msDest.stream;

    // Start audio context (must be after a user gesture in most browsers)
    if (this.ctx.state !== "running") await this.ctx.resume();
    await this.audioEl.play().catch(console.error);
  }

  private onDecoded(audioData: AudioData) {
    // Copy planar float PCM from AudioData
    const frames = audioData.numberOfFrames; // should be ~240 or 480 based on decoder
    const ch = audioData.numberOfChannels; // expect 2
    const outRate = audioData.sampleRate; // may be 24000 (as configured)

    const planes = [new Float32Array(frames), new Float32Array(frames)]; // left, right
    const data = new Float32Array(frames * ch);
    audioData.copyTo(data, { planeIndex: 1, format: "f32" });
    for (let i = 0; i < data.length; i++) {
      planes[i % 2][Math.floor(i / 2)] = data[i];
    }
    audioData.close();
    this.push(planes);
  }

  public pushOpus(packet: Uint8Array, ptsUsec?: number) {
    // 240 samples @ 24kHz = 10 ms
    const durationUsec = Math.round((240 / this.sampleRate) * 1_000_000);

    const timestamp = ptsUsec ?? this.ptsUsec;
    const chunk = new EncodedAudioChunk({
      type: "key",
      timestamp,
      duration: durationUsec,
      data: packet,
    });

    this.decoder?.decode(chunk);

    if (ptsUsec == null) this.ptsUsec += durationUsec;
  }

  /** Push one planar frame (Float32 per channel). */
  push(planes: Float32Array[]): void {
    if (!this.node) throw new Error("PcmSink not initialized â€” call init()");
    if (planes.length !== this.channels)
      throw new Error(
        `Expected ${this.channels} channels, got ${planes.length}`,
      );
    this.node.port.postMessage(planes);
  }

  /** Get available audio output devices (requires HTTPS; labels need prior permission). */
  static async listOutputDevices(): Promise<MediaDeviceInfo[]> {
    // To get *labels*, browsers typically require prior device permission:
    // await navigator.mediaDevices.getUserMedia({ audio: true }).catch(() => {});
    const devices = await navigator.mediaDevices.enumerateDevices();
    return devices.filter((d) => d.kind === "audiooutput");
  }

  /** Switch the output device. Pass deviceId from enumerateDevices(). */
  async setOutputDevice(deviceId: string): Promise<void> {
    const el = this.audioEl;
    const anyEl = el as unknown as {
      setSinkId?: (id: string) => Promise<void>;
    };

    if (!anyEl.setSinkId) {
      throw new Error("setSinkId is not supported in this browser");
    }
    // setSinkId requires a secure context (HTTPS) and user gesture in some browsers
    await anyEl.setSinkId!(deviceId);
  }

  /** Convenience: return current device sinkId if available. */
  get currentSinkId(): string | undefined {
    return (this.audioEl as unknown as { sinkId?: string }).sinkId;
  }

  async resume(): Promise<void> {
    if (this.ctx.state !== "running") await this.ctx.resume();
    await this.audioEl.play().catch(() => {});
  }

  async close(): Promise<void> {
    try {
      this.node.disconnect();
    } catch (err) {
      console.error("Error disconnecting node:", err);
    }
    try {
      this.audioEl.srcObject = null;
    } catch (err) {
      console.error("Error clearing audio element srcObject:", err);
    }
    await this.ctx.close();
  }
}

const processorCode = `
class PcmSinkProcessor extends AudioWorkletProcessor {
  constructor() {
    super();
    this.queue = [];
    this.port.onmessage = (e) => {
      this.queue.push(e.data);
    };
  }

  process(_inputs, outputs) {
    const output = outputs[0];

    if (this.queue.length > 0) {
      const planes = this.queue.shift(); // [Float32Array, Float32Array]
      for (let c = 0; c < output.length; c++) {
        if (planes[c]) output[c].set(planes[c]);
        else output[c].fill(0);
      }
    } else {
      // if nothing buffered, play silence (avoids crackling)
      for (let c = 0; c < output.length; c++) {
        output[c].fill(0);
      }
    }
    return true;
  }
}

registerProcessor("pcm-sink", PcmSinkProcessor);
`;

const blob = new Blob([processorCode], { type: "application/javascript" });
const audioWorkletBlobUrl = URL.createObjectURL(blob);
